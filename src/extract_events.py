import os, json, csv
from datetime import datetime
from config import CHANGES_ROOT, OUT_ROOT


# Converts Gerrit date format (ISO) to Python datetime
def iso_dt(s):
    s = s.replace("Z", "+00:00")
    # remove microseconds if they exist
    if '.' in s:
        if "+" in s:
            base, tz = s.split("+", 1)
            s = base.split(".")[0] + "+" + tz
        else:
            s = s.split(".")[0]
    return datetime.fromisoformat(s)


# Finds abandon and reopen events in message history
def scan_messages(msgs):
    abandon = restore = None
    abandon_actor = restore_actor = None
    for m in msgs:
        text = (m.get("message") or "").strip()
        date = m.get("date")

        # find first "Abandoned" message
        if not abandon and ("abandoned" in text.lower()):
            abandon = date
            abandon_actor = (m.get("author") or {}).get("_account_id")

        # find first "Restored" or "Reopened" after abandon
        elif abandon and not restore and (
            text.lower().startswith("restored") or text.lower().startswith("reopened")
        ):
            restore = date
            restore_actor = (m.get("author") or {}).get("_account_id")

    return abandon, abandon_actor, restore, restore_actor


rows = []
print(f"Scanning files in {CHANGES_ROOT}...")

# Go through all JSON files in the changes folder
for root, _, files in os.walk(CHANGES_ROOT):
    for fn in files:
        if not fn.endswith(".json"):
            continue

        try:
            ch = json.load(open(os.path.join(root, fn), encoding="utf-8"))
        except:
            continue  # skip unreadable files

        msgs = ch.get("messages", [])
        abandon_ts, abandon_actor, reopen_ts, reopen_actor = scan_messages(msgs)

        # keep only if both abandon and reopen exist
        if not (abandon_ts and reopen_ts):
            continue

        # Metric calculations
        owner = (ch.get("owner") or {}).get("_account_id")

        # messages before abandon event
        before_abandon = [
            m for m in msgs if m.get("date") and iso_dt(m["date"]) <= iso_dt(abandon_ts)
        ]

        # number of patchsets before abandon
        revs = [
            m.get("_revision_number")
            for m in before_abandon
            if isinstance(m.get("_revision_number"), int)
            and m.get("tag") != "autogenerated:gerrit:set_topic"
        ]
        num_patchsets_before = max(revs) if revs else 1

        # count unique reviewers before abandon (excluding owner)
        reviewers = {
            (m.get("author") or {}).get("_account_id")
            for m in before_abandon
            if (m.get("author") or {}).get("_account_id") != owner
        }

        # delay in days between abandon and reopen
        delay = (iso_dt(reopen_ts) - iso_dt(abandon_ts)).total_seconds() / 86400.0

        # build one row of final dataset
        rows.append({
            "change_id": ch.get("change_id"),
            "numeric_id": ch.get("_number"),
            "project": ch.get("project"),
            "branch": ch.get("branch"),
            "owner_id": owner,
            "created_ts": iso_dt(ch.get("created")).strftime("%Y-%m-%d %H:%M:%S"),
            "abandon_ts": iso_dt(abandon_ts).strftime("%Y-%m-%d %H:%M:%S"),
            "reopen_ts": iso_dt(reopen_ts).strftime("%Y-%m-%d %H:%M:%S"),
            "reopen_delay_days": round(delay, 4),
            "same_owner_reopen": (owner == reopen_actor),
            "final_status": ch.get("status"),
            "num_patchsets_before_abandon": num_patchsets_before,
            "reviewer_count_before_abandon": len(reviewers),
            "last_updated_ts": iso_dt(ch.get("updated")).strftime("%Y-%m-%d %H:%M:%S"),
        })

#Save everything in reopen_events.csv 
output_file = os.path.join(OUT_ROOT, "reopen_events.csv")

if rows:
    with open(output_file, "w", newline="", encoding="utf-8") as f:
        writer = csv.DictWriter(f, fieldnames=list(rows[0].keys()))
        writer.writeheader()
        writer.writerows(rows)
    print(f"Done! {len(rows)} reopened changes saved to {output_file}")
else:
    print("No reopened changes found in the scanned files.")
